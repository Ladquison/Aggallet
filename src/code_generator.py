from pathlib import Path
from jinja2 import Environment, FileSystemLoader, Template
from setting_loader import SettingLoader
from spec_loader import SpecLoader
from type_loader import TypeLoader

# generate source code with template engine Jinja2
class CodeGenerator:
    # constructor
    def __init__(self, current_dir: Path, output_dir: str
                 , callback_enable: bool, setting_loader: SettingLoader
                 , type_loader: TypeLoader, api_loader: SpecLoader):
        self.current_dir = current_dir
        self.output_dir = output_dir
        self.callback_enable = callback_enable
        self.setting_loader = setting_loader
        self.type_loader = type_loader
        self.api_loader = api_loader
        self.callback_loader = None
        self.type_data_wasm = type_loader.get_mapping_info("wasm")
        self.type_data_ts = type_loader.get_mapping_info("ts")

    # set callback loader individually because callback may be disabled
    def set_callback_loader(self, callback_loader: SpecLoader):
        self.callback_loader = callback_loader
    
    # generate source code related to WebAssembly
    def generate_wasm(self):
        ext = self.setting_loader.get("wasm_ext")
        self._generate_wasm_provider(ext)

    # generate source code related to TypeScript
    def generate_ts(self):
        self._generate_ts_wrapper()
        self._generate_ts_type_def()

    # generate source code related to callback
    def generate_callback(self):
        if self.callback_enable:
            data = self.setting_loader.get("callback")
            function_list = self.callback_loader.function_list
            self._generate_wasm_callback(data, function_list)
            self._generate_ts_callback(data, function_list)

    # generate WebAssembly function provider
    # in this code, functions called from TypeScript are defined
    def _generate_wasm_provider(self, ext: str):
        impl_wasm = self.setting_loader.get("impl_wasm")
        template = self._get_template(impl_wasm.get("template"))

        info: dict = {}
        info["import_module"] = impl_wasm.get("import_module")
        info["call_prefix"] = impl_wasm.get("call_prefix")
        info["binding_name"] = impl_wasm.get("binding_name")
        info["functions"] = self.api_loader.function_list
        info["get_type"] = self._get_type_wasm
        info["callback_enable"] = self.callback_enable
        if self.callback_enable:
            callback = self.setting_loader.get("callback")
            info["callback_function_name_add"] = callback.get("function_name_add")
            info["callback_function_name_remove"] = callback.get("function_name_remove")
        
        output = template.render(info)
        with open(self.current_dir / self.output_dir / (impl_wasm.get("name") + "." + ext)
                  , "w", encoding="utf-8") as f:
            f.write(output)

    # generate callback definition for WebAssembly
    # in C++ code, only callback function IDs are defined
    def _generate_wasm_callback(self, data, function_list):
        template = self._get_template(data.get("template_wasm"))

        info: dict = {}
        info["enum_name"] = data.get("enum_name")
        info["functions"] = function_list
        info["get_type"] = self._get_type_wasm

        output = template.render(info)
        ext = self.setting_loader.get("wasm_ext")

        # in C++ code, definition are written in header file
        if ext == "cpp":
            ext = "h"

        with open(self.current_dir / self.output_dir / (data.get("file_name") + "." + ext)
                  , "w", encoding="utf-8") as f:
            f.write(output)

    # generate callback defnition for TypeScript
    def _generate_ts_callback(self, data, function_list):
        template = self._get_template(data.get("template_ts"))

        info: dict = {}
        info["enum_name"] = data.get("enum_name")
        info["mapping_variable_name"] = data.get("mapping_variable_name")
        info["functions"] = function_list
        info["get_type"] = self._get_type_ts

        output = template.render(info)
        with open(self.current_dir / self.output_dir / (data.get("file_name") + ".ts")
                  , "w", encoding="utf-8") as f:
            f.write(output)

    # generate wrapper code for calling functions implemented in WebAssembly
    # in C++ code, use JavaScript code generated by Emscripten
    def _generate_ts_wrapper(self):
        impl_ts = self.setting_loader.get("impl_ts")
        template = self._get_template(impl_ts.get("template_wrapper"))

        info: dict = {}
        info["module_name_wasm"] = self.setting_loader.get("module_name_wasm")
        info["class_name"] = impl_ts.get("name")
        info["wasm_directory"] = impl_ts.get("wasm_directory")
        info["wasm_js_directory"] = impl_ts.get("wasm_js_directory")
        info["type_def_directory"] = impl_ts.get("type_def_directory")
        info["functions"] = self.api_loader.function_list
        info["get_type"] = self._get_type_ts
        info["get_default"] = self._get_default
        info["callback_enable"] = self.callback_enable
        if self.callback_enable:
            callback = self.setting_loader.get("callback")
            info["mapping_variable_name"] = callback.get("mapping_variable_name")
            info["callback_file_name"] = callback.get("file_name")
            info["callback_function_name_add"] = callback.get("function_name_add")
            info["callback_function_name_remove"] = callback.get("function_name_remove")
            info["callback_enum_name"] = callback.get("enum_name")
        
        output = template.render(info)
        with open(self.current_dir / self.output_dir / (impl_ts.get("name") + ".ts")
                  , "w", encoding="utf-8") as f:
            f.write(output)

    # generate type definition for functions implemented in WebAssembly
    def _generate_ts_type_def(self):
        impl_ts = self.setting_loader.get("impl_ts")
        template = self._get_template(impl_ts.get("template_type_def"))

        info: dict = {}
        module_name = self.setting_loader.get("module_name_wasm")
        info["module_name_wasm"] = module_name
        info["wasm_js_directory"] = impl_ts.get("wasm_js_directory")
        info["functions"] = self.api_loader.function_list
        info["get_type"] = self._get_type_ts
        info["callback_enable"] = self.callback_enable
        if self.callback_enable:
            callback = self.setting_loader.get("callback")
            info["callback_function_name_add"] = callback.get("function_name_add")
            info["callback_function_name_remove"] = callback.get("function_name_remove")
        
        output = template.render(info)
        with open(self.current_dir / self.output_dir / (module_name + ".d.ts")
                  , "w", encoding="utf-8") as f:
            f.write(output)
    
    # get Jinja2 template with j2 file path
    def _get_template(self, file_path: str) -> Template:
        path = self.current_dir / file_path
        dir = str(path.parent)
        file = path.name
        env = Environment(loader=FileSystemLoader(dir))
        return env.get_template(file)

    # get type in language used to implement WebAssembly
    def _get_type_wasm(self, type: str) -> str:
        return self.type_data_wasm.get(type)
    
    # get type in TypeScript
    def _get_type_ts(self, type: str) -> str:
        return self.type_data_ts.get(type)
    
    # get default value defined in YAML file
    def _get_default(self, type: str):
        return self.type_loader.get_default(type)